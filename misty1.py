from typing import Dict, List, Union

# Реалізація таблиць підстановки S7 та S9 згідно стандарту (хардкодимо їх ^^ )
# S7: 7-біт → 7-біт 
S7 = [
    0x1b, 0x32, 0x33, 0x5a, 0x3b, 0x10, 0x17, 0x54, 0x5b, 0x1a, 0x72, 0x73, 0x6b, 0x2c, 0x66, 0x49,
    0x1f, 0x24, 0x13, 0x6c, 0x37, 0x2e, 0x3f, 0x4a, 0x5d, 0x0f, 0x40, 0x56, 0x25, 0x51, 0x1c, 0x04,
    0x0b, 0x46, 0x20, 0x0d, 0x7b, 0x35, 0x44, 0x42, 0x2b, 0x1e, 0x41, 0x14, 0x4b, 0x79, 0x15, 0x6f,
    0x0e, 0x55, 0x09, 0x36, 0x74, 0x0c, 0x67, 0x53, 0x28, 0x0a, 0x7e, 0x38, 0x02, 0x07, 0x60, 0x29,
    0x19, 0x12, 0x65, 0x2f, 0x30, 0x39, 0x08, 0x68, 0x5f, 0x78, 0x2a, 0x4c, 0x64, 0x45, 0x75, 0x3d,
    0x59, 0x48, 0x03, 0x57, 0x7c, 0x4f, 0x62, 0x3c, 0x1d, 0x21, 0x5e, 0x27, 0x6a, 0x70, 0x4d, 0x3a,
    0x01, 0x6d, 0x6e, 0x63, 0x18, 0x77, 0x23, 0x05, 0x26, 0x76, 0x00, 0x31, 0x2d, 0x7a, 0x7f, 0x61,
    0x50, 0x22, 0x11, 0x06, 0x47, 0x16, 0x52, 0x4e, 0x71, 0x3e, 0x69, 0x43, 0x34, 0x5c, 0x58, 0x7d, 
]

# S9: 9-біт → 9-біт 
S9 = [
    # 00
    0x1c3, 0x0cb, 0x153, 0x19f, 0x1e3, 0x0e9, 0x0fb, 0x035, 0x181, 0x0b9, 0x117, 0x1eb, 0x133, 0x009, 0x02d, 0x0d3,
    # 01
    0x0c7, 0x14a, 0x037, 0x07e, 0x0eb, 0x164, 0x193, 0x1d8, 0x0a3, 0x11e, 0x055, 0x02c, 0x01d, 0x1a2, 0x163, 0x118,
    # 02
    0x14b, 0x152, 0x1d2, 0x00f, 0x02b, 0x030, 0x13a, 0x0e5, 0x111, 0x138, 0x18e, 0x063, 0x0e3, 0x0c8, 0x1f4, 0x01b,
    # 03
    0x001, 0x09d, 0x0f8, 0x1a0, 0x16d, 0x1f3, 0x01c, 0x146, 0x07d, 0x0d1, 0x082, 0x1ea, 0x183, 0x12d, 0x0f4, 0x19e,
    # 04
    0x1d3, 0x0dd, 0x1e2, 0x128, 0x1e0, 0x0ec, 0x059, 0x091, 0x011, 0x12f, 0x026, 0x0dc, 0x0b0, 0x18c, 0x10f, 0x1f7,
    # 05
    0x0e7, 0x16c, 0x0b6, 0x0f9, 0x0d8, 0x151, 0x101, 0x14c, 0x103, 0x0b8, 0x154, 0x12b, 0x1ae, 0x017, 0x071, 0x00c,
    # 06
    0x047, 0x058, 0x07f, 0x1a4, 0x134, 0x129, 0x084, 0x15d, 0x19d, 0x1b2, 0x1a3, 0x048, 0x07c, 0x051, 0x1ca, 0x023,
    # 07
    0x13d, 0x1a7, 0x165, 0x03b, 0x042, 0x0da, 0x192, 0x0ce, 0x0c1, 0x06b, 0x09f, 0x1f1, 0x12c, 0x184, 0x0fa, 0x196,
    # 08
    0x1e1, 0x169, 0x17d, 0x031, 0x180, 0x10a, 0x094, 0x1da, 0x186, 0x13e, 0x11c, 0x060, 0x175, 0x1cf, 0x067, 0x119,
    # 09
    0x065, 0x068, 0x099, 0x150, 0x008, 0x007, 0x17c, 0x0b7, 0x024, 0x019, 0x0de, 0x127, 0x0db, 0x0e4, 0x1a9, 0x052,
    # 0a
    0x109, 0x090, 0x19c, 0x1c1, 0x028, 0x1b3, 0x135, 0x16a, 0x176, 0x0df, 0x1e5, 0x188, 0x0c5, 0x16e, 0x1de, 0x1b1,
    # 0b
    0x0c3, 0x1df, 0x036, 0x0ee, 0x1ee, 0x0f0, 0x093, 0x049, 0x09a, 0x1b6, 0x069, 0x081, 0x125, 0x00b, 0x05e, 0x0b4,
    # 0c
    0x149, 0x1c7, 0x174, 0x03e, 0x13b, 0x1b7, 0x08e, 0x1c6, 0x0ae, 0x010, 0x095, 0x1ef, 0x04e, 0x0f2, 0x1fd, 0x085,
    # 0d
    0x0fd, 0x0f6, 0x0a0, 0x16f, 0x083, 0x08a, 0x156, 0x09b, 0x13c, 0x107, 0x167, 0x098, 0x1d0, 0x1e9, 0x003, 0x1fe,
    # 0e
    0x0bd, 0x122, 0x089, 0x0d2, 0x18f, 0x012, 0x033, 0x06a, 0x142, 0x0ed, 0x170, 0x11b, 0x0e2, 0x14f, 0x158, 0x131,
    # 0f
    0x147, 0x05d, 0x113, 0x1cd, 0x079, 0x161, 0x1a5, 0x179, 0x09e, 0x1b4, 0x0cc, 0x022, 0x132, 0x01a, 0x0e8, 0x004,
    # 10
    0x187, 0x1ed, 0x197, 0x039, 0x1bf, 0x1d7, 0x027, 0x18b, 0x0c6, 0x09c, 0x0d0, 0x14e, 0x06c, 0x034, 0x1f2, 0x06e,
    # 11
    0x0ca, 0x025, 0x0ba, 0x191, 0x0fe, 0x013, 0x106, 0x02f, 0x1ad, 0x172, 0x1db, 0x0c0, 0x10b, 0x1d6, 0x0f5, 0x1ec,
    # 12
    0x10d, 0x076, 0x114, 0x1ab, 0x075, 0x10c, 0x1e4, 0x159, 0x054, 0x11f, 0x04b, 0x0c4, 0x1be, 0x0f7, 0x029, 0x0a4,
    # 13
    0x00e, 0x1f0, 0x077, 0x04d, 0x17a, 0x086, 0x08b, 0x0b3, 0x171, 0x0bf, 0x10e, 0x104, 0x097, 0x15b, 0x160, 0x168,
    # 14
    0x0d7, 0x0bb, 0x066, 0x1ce, 0x0fc, 0x092, 0x1c5, 0x06f, 0x016, 0x04a, 0x0a1, 0x139, 0x0af, 0x0f1, 0x190, 0x00a,
    # 15
    0x1aa, 0x143, 0x17b, 0x056, 0x18d, 0x166, 0x0d4, 0x1fb, 0x14d, 0x194, 0x19a, 0x087, 0x1f8, 0x123, 0x0a7, 0x1b8,
    # 16
    0x141, 0x03c, 0x1f9, 0x140, 0x02a, 0x155, 0x11a, 0x1a1, 0x198, 0x0d5, 0x126, 0x1af, 0x061, 0x12e, 0x157, 0x1dc,
    # 17
    0x072, 0x18a, 0x0aa, 0x096, 0x115, 0x0ef, 0x045, 0x07b, 0x08d, 0x145, 0x053, 0x05f, 0x178, 0x0b2, 0x02e, 0x020,
    # 18
    0x1d5, 0x03f, 0x1c9, 0x1e7, 0x1ac, 0x044, 0x038, 0x014, 0x0b1, 0x16b, 0x0ab, 0x0b5, 0x05a, 0x182, 0x1c8, 0x1d4,
    # 19
    0x018, 0x177, 0x064, 0x0cf, 0x06d, 0x100, 0x199, 0x130, 0x15a, 0x005, 0x120, 0x1bb, 0x1bd, 0x0e0, 0x04f, 0x0d6,
    # 1a
    0x13f, 0x1c4, 0x12a, 0x015, 0x006, 0x0ff, 0x19b, 0x0a6, 0x043, 0x088, 0x050, 0x15f, 0x1e8, 0x121, 0x073, 0x17e,
    # 1b
    0x0bc, 0x0c2, 0x0c9, 0x173, 0x189, 0x1f5, 0x074, 0x1cc, 0x1e6, 0x1a8, 0x195, 0x01f, 0x041, 0x00d, 0x1ba, 0x032,
    # 1c
    0x03d, 0x1d1, 0x080, 0x0a8, 0x057, 0x1b9, 0x162, 0x148, 0x0d9, 0x105, 0x062, 0x07a, 0x021, 0x1ff, 0x112, 0x108,
    # 1d
    0x1c0, 0x0a9, 0x11d, 0x1b0, 0x1a6, 0x0cd, 0x0f3, 0x05c, 0x102, 0x05b, 0x1d9, 0x144, 0x1f6, 0x0ad, 0x0a5, 0x03a,
    # 1e
    0x1cb, 0x136, 0x17f, 0x046, 0x0e1, 0x01e, 0x1dd, 0x0e6, 0x137, 0x1fa, 0x185, 0x08c, 0x08f, 0x040, 0x1b5, 0x0be,
    # 1f
    0x078, 0x000, 0x0ac, 0x110, 0x15e, 0x124, 0x002, 0x1bc, 0x0a2, 0x0ea, 0x070, 0x1fc, 0x116, 0x15c, 0x04c, 0x1c2,
]

#Підстановка S7 (7-біт → 7-біт)
def s7(x: int) -> int:
    
    if not (0 <= x <= 0x7F):
        raise ValueError("Вхідне значення для S7 повинно бути 7-бітним")
    return S7[x]

#Підстановка S9 (9-біт → 9-біт)
def s9(x: int) -> int:
    
    if not (0 <= x <= 0x1FF):
        raise ValueError("Вхідне значення для S9 повинно бути 9-бітним")
    return S9[x]

# Функція FI  
def fi(x: int, ki: int) -> int:
    # (1) Розбиття X на L0(9) || R0(7)
    l0 = (x >> 7) & 0x1FF
    r0 = x & 0x7F

    # Розбиття KI на KI_L(7) || KI_R(9)
    ki_l = (ki >> 9) & 0x7F
    ki_r = ki & 0x1FF

    # (2) R1 = S9(L0) XOR Extnd(R0)   (R1 має бути 9 біт)
    r1 = (s9(l0) ^ r0) & 0x1FF

    # (3) L1 = R0
    l1 = r0

    # (4) R2 = S7(L1) XOR Trunc(R1) XOR KI_L   (R2 має бути 7 біт)
    r2 = (s7(l1) ^ (r1 & 0x7F) ^ ki_l) & 0x7F

    # (5) L2 = R1 XOR KI_R   (L2 має бути 9 біт)
    l2 = (r1 ^ ki_r) & 0x1FF

    # (6) R3 = S9(L2) XOR Extnd(R2)   (R3 має бути 9 біт)
    r3 = (s9(l2) ^ r2) & 0x1FF

    # (7) L3 = R2
    l3 = r2

    # (8) Y = L3 || R3
    return ((l3 & 0x7F) << 9) | (r3 & 0x1FF)


#Функція FO 
def fo(x32: int, ko: list[int], ki: list[int]) -> int:
    
    # Базові перевірки довжин 
    if len(ko) != 4:
        raise ValueError("FO: ko повинно містити 4 елементи (KO1..KO4)")
    if len(ki) != 3:
        raise ValueError("FO: ki повинно містити 3 елементи (KI1..KI3)")

    # (1) X32 = L0 || R0
    l = (x32 >> 16) & 0xFFFF
    r = x32 & 0xFFFF

    # (2) for j = 1..3
    for j in range(3):
        # Rj = FI(L_{j-1} XOR KO_j, KI_j) XOR R_{j-1}
        t = fi((l ^ (ko[j] & 0xFFFF)) & 0xFFFF, ki[j] & 0xFFFF)
        r_new = (t ^ r) & 0xFFFF

        # Lj = R_{j-1}
        l_new = r

        l, r = l_new, r_new

    # (3) Y32 = (L3 XOR KO4) || R3
    y_l = (l ^ (ko[3] & 0xFFFF)) & 0xFFFF
    y = ((y_l << 16) | (r & 0xFFFF)) & 0xFFFFFFFF
    return y



#Функція FL 
def fl(x32: int, kl: list[int]) -> int:

    if len(kl) != 2:
        raise ValueError("FL: kl повинно містити 2 елементи (KL_IL, KL_IR)")

    xl = (x32 >> 16) & 0xFFFF
    xr = x32 & 0xFFFF

    kl_il = kl[0] & 0xFFFF
    kl_ir = kl[1] & 0xFFFF

    # (2) YR = (XL AND KL_IL) XOR XR
    yr = ((xl & kl_il) ^ xr) & 0xFFFF

    # (3) YL = XL XOR (YR OR KL_IR)
    yl = (xl ^ (yr | kl_ir)) & 0xFFFF

    # (4) Y32 = YL || YR
    return ((yl << 16) | yr) & 0xFFFFFFFF


#Функція FL^-1    
def fl_inv(y32: int, kl: list[int]) -> int:
    
    if len(kl) != 2:
        raise ValueError("FL^-1: kl повинно містити 2 елементи (KL_IL, KL_IR)")

    yl = (y32 >> 16) & 0xFFFF
    yr = y32 & 0xFFFF

    kl_il = kl[0] & 0xFFFF
    kl_ir = kl[1] & 0xFFFF

    # (2) XL = YL XOR (YR OR KL_IR)
    xl = (yl ^ (yr | kl_ir)) & 0xFFFF

    # (3) XR = (XL AND KL_IL) XOR YR
    xr = ((xl & kl_il) ^ yr) & 0xFFFF

    # (4) X32 = XL || XR
    return ((xl << 16) | xr) & 0xFFFFFFFF

#Переведення індексу в діапазон 1..8 
def _idx8(j: int) -> int:
    return ((j - 1) % 8) + 1


#Перетворює 128-бітний ключ у список 8 слів по 16 біт: [K1..K8].
def _split_key_to_words(key128: Union[int, bytes, str]) -> List[int]:
    
    if isinstance(key128, str):
        s = key128.strip().lower().replace("0x", "").replace(" ", "")
        if len(s) != 32:
            raise ValueError("Ключ у hex має бути 32 hex-символи (128 біт).")
        key_int = int(s, 16)
    elif isinstance(key128, bytes):
        if len(key128) != 16:
            raise ValueError("Ключ у bytes має бути рівно 16 байтів (128 біт).")
        key_int = int.from_bytes(key128, byteorder="big")
    elif isinstance(key128, int):
        if key128 < 0 or key128 >= (1 << 128):
            raise ValueError("Ключ int має бути 128-бітним (0..2^128-1).")
        key_int = key128
    else:
        raise TypeError("Ключ має бути int, bytes(16) або hex-рядок(32).")

    #  K1 — старші 16 біт, K8 — молодші 16 біт
    K = []
    for i in range(8):
        shift = (7 - i) * 16
        K.append((key_int >> shift) & 0xFFFF)
    return K  # [K1..K8]

#Розгортання ключів MISTY1 
def GenerateRoundKeys(key128: Union[int, bytes, str]) -> Dict[str, List]:
    
    K = _split_key_to_words(key128)
    K1 = [None] + K  # K1[1]..K1[8]

    # 1) K' (Kp) = FI(Ki, K(i+1))
    Kp = [None] + [0] * 8  # Kp[1]..Kp[8]
    for i in range(1, 8):
        Kp[i] = fi(K1[i], K1[i + 1]) & 0xFFFF
    Kp[8] = fi(K1[8], K1[1]) & 0xFFFF

    # 2) KO і KI для i = 1..8
    KO: List[List[int]] = []
    KI: List[List[int]] = []

    for i in range(1, 9):
        ko1 = K1[_idx8(i)]
        ko2 = K1[_idx8(i + 2)]
        ko3 = K1[_idx8(i + 7)]
        ko4 = K1[_idx8(i + 4)]
        KO.append([ko1, ko2, ko3, ko4])

        ki1 = Kp[_idx8(i + 5)]
        ki2 = Kp[_idx8(i + 1)]
        ki3 = Kp[_idx8(i + 3)]
        KI.append([ki1, ki2, ki3])

    # 3) KL для i = 1..10
    KL: List[List[int]] = []
    for i in range(1, 11):
        if i % 2 == 1:
            # непарне
            a = (i + 1) // 2
            kl_l = K1[_idx8(a)]
            kl_r = Kp[_idx8(a + 6)]
        else:
            # парне
            a = i // 2
            kl_l = Kp[_idx8(a + 2)]
            kl_r = K1[_idx8(a + 4)]
        KL.append([kl_l, kl_r])

    return {
        "K": K,                  # [K1..K8]
        "Kp": Kp[1:],            # [K'1..K'8]
        "KO": KO,                # 8x4
        "KI": KI,                # 8x3
        "KL": KL,                # 10x2
    }


#Шифрує 1 блок (64 біти = 8 байтів) 
def _hx32(x: int) -> str:
    return f"0x{x & 0xFFFFFFFF:08x}"

#Шифрування 1го блоку інформації 
def EncryptBlock(block: Union[bytes, bytearray], key128: Union[int, bytes, str]) -> bytes:
    if not isinstance(block, (bytes, bytearray)):
        raise TypeError("EncryptBlock: block має бути bytes або bytearray")
    if len(block) != 8:
        raise ValueError("EncryptBlock: block має бути рівно 8 байтів (64 біти)")

    rk = GenerateRoundKeys(key128)
    KO = rk["KO"]  # 8x4
    KI = rk["KI"]  # 8x3
    KL = rk["KL"]  # 10x2

    # P = L0 || R0 (по 32 біти)
    L = int.from_bytes(block[0:4], "big") & 0xFFFFFFFF
    R = int.from_bytes(block[4:8], "big") & 0xFFFFFFFF

    # i = 1,3,5,7
    for i in (1, 3, 5, 7):
        Ri = fl(L, KL[i - 1])  # KL_i
        Li = (fl(R, KL[i]) ^ fo(Ri, KO[i - 1], KI[i - 1])) & 0xFFFFFFFF  # KL_{i+1}, KO_i, KI_i

        L, R = (Ri ^ fo(Li, KO[i], KI[i])) & 0xFFFFFFFF, Li  # KO_{i+1}, KI_{i+1}

    # i = 9
    R9 = fl(L, KL[8])  # KL9
    L9 = fl(R, KL[9])  # KL10

    return (L9 & 0xFFFFFFFF).to_bytes(4, "big") + (R9 & 0xFFFFFFFF).to_bytes(4, "big")

#Розшифрування 1го блоку інформації 
def DecryptBlock(block: Union[bytes, bytearray], key128: Union[int, bytes, str]) -> bytes:
    
    if not isinstance(block, (bytes, bytearray)):
        raise TypeError("DecryptBlock: block має бути bytes або bytearray")
    if len(block) != 8:
        raise ValueError("DecryptBlock: block має бути рівно 8 байтів (64 біти)")

    rk = GenerateRoundKeys(key128)
    KO = rk["KO"]  # 8 x 4 
    KI = rk["KI"]  # 8 x 3 
    KL = rk["KL"]  # 10 x 2 

    # C = L9 || R9 (по 32 біти)
    L9 = int.from_bytes(block[0:4], "big") & 0xFFFFFFFF
    R9 = int.from_bytes(block[4:8], "big") & 0xFFFFFFFF

    #   L8 = FL^-1(R9, KL9)
    #   R8 = FL^-1(L9, KL10)
    L = fl_inv(R9, KL[8]) & 0xFFFFFFFF   
    R = fl_inv(L9, KL[9]) & 0xFFFFFFFF  

    # При розшифруванні відомі (Lnext, Rnext), треба знайти (Lprev, Rprev):
    #   Li = Rnext
    #   Ri = Lnext XOR FO(Li, KO_{i+1}, KI_{i+1})
    #   Lprev = FL^-1(Ri, KL_i)
    #   Rprev = FL^-1( Li XOR FO(Ri, KO_i, KI_i), KL_{i+1} )
    for i in (7, 5, 3, 1):
        # 1) Li = Rnext
        Li = R & 0xFFFFFFFF

        # 2) Ri = Lnext XOR FO(Li, KO_{i+1}, KI_{i+1})
        Ri = (L ^ fo(Li, KO[i], KI[i])) & 0xFFFFFFFF

        # 3) Lprev = FL^-1(Ri, KL_i)
        Lprev = fl_inv(Ri, KL[i - 1]) & 0xFFFFFFFF

        # 4) Rprev = FL^-1( Li XOR FO(Ri, KO_i, KI_i), KL_{i+1} )
        #    KO[i-1] == KO_i, KI[i-1] == KI_i, KL[i] == KL_{i+1}
        tmp = (Li ^ fo(Ri, KO[i - 1], KI[i - 1])) & 0xFFFFFFFF
        Rprev = fl_inv(tmp, KL[i]) & 0xFFFFFFFF

        # Оновлюємо стан на попередній
        L, R = Lprev, Rprev

    # P = L0 || R0
    return (L & 0xFFFFFFFF).to_bytes(4, "big") + (R & 0xFFFFFFFF).to_bytes(4, "big")


